---
title: "Detecting Vandalism on Wikipedia"
author: "By John Bobo based on a problem set from MITâ€™s Analytics Edge MOOC"
date: "May 25, 2016"
output:
    html_document:
        theme: cerulean
        keep_md: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(digits = 3)
```

[Wikipedia](http://en.wikipedia.org/wiki/Wikipedia) is a free online encyclopedia that anyone can edit and contribute to. It is available in many languages and is growing all the time. On the English language version of Wikipedia:

- There are currently [4.7 million pages](http://en.wikipedia.org/wiki/Wikipedia:Size_of_Wikipedia).
- There have been a total over [760 million edits](http://en.wikipedia.org/wiki/Wikipedia:Pruning_article_revisions) (also called revisions) over its lifetime.
- There are approximately [130,000 edits per day](http://en.wikipedia.org/wiki/Wikipedia:WikiProject_Editing_trends/Raw_data/Revisions_per_day).

One of the consequences of being editable by anyone is that some people _vandalize_ pages. This can take the form of removing content, adding promotional or inappropriate content, or more subtle shifts that change the meaning of the article. With this many articles and edits per day it is difficult for humans to detect all instances of vandalism and _revert_ (undo) them. As a result, Wikipedia uses _bots_ - computer programs that automatically revert edits that look like vandalism. In this assignment we will attempt to develop a vandalism detector that uses machine learning to distinguish between a valid edit and vandalism.

The data for this problem is based on the revision history of the page [Language](http://en.wikipedia.org/wiki/Language). Wikipedia provides a history for each page that consists of the state of the page at each revision. Rather than manually considering each revision, a script was run that checked whether edits stayed or were reverted. If a change was eventually reverted then that revision is marked as vandalism. This may result in some misclassifications, but the script performs well enough for our needs.

As a result of this preprocessing, some common processing tasks have already been done, including lower-casing and punctuation removal. The columns in the dataset are:

- Vandal = 1 if this edit was vandalism, 0 if not.
- Minor = 1 if the user marked this edit as a "minor edit", 0 if not.
- Loggedin = 1 if the user made this edit while using a Wikipedia account, 0 if they did not.
- Added = The _unique_ words added.
- Removed = The _unique_ words removed.

Notice the repeated use of _unique_. The data we have available is not the traditional bag of words - rather it is the set of words that were removed or added. For example, if a word was removed multiple times in a revision it will only appear one time in the "Removed" column.

#### Problem 1.1 - Bags of Words

(1 point possible)
Load the data wiki.csv with the option stringsAsFactors=FALSE, calling the data frame "wiki". Convert the "Vandal" column to a factor using the command wiki$Vandal = as.factor(wiki$Vandal).
```{r}
wiki <- read.csv("/Users/johnbobo/analytics_edge/data/wiki.csv", stringsAsFactors = FALSE)

wiki$Vandal <- as.factor(wiki$Vandal)
```

*How many cases of vandalism were detected in the history of this page?*
```{r}
table(wiki$Vandal)
```
**Answer:** 1815.

***

#### Problem 1.2 - Bags of Words

(2 points possible)
We will now use the bag of words approach to build a model. We have two columns of textual data, with different meanings. For example, adding rude words has a different meaning to removing rude words. We'll start like we did in class by building a document term matrix from the Added column. The text already is lowercase and stripped of punctuation. So to pre-process the data, just complete the following four steps:

1) Create the corpus for the Added column, and call it "corpusAdded".
```{r}
library(tm)

corpusAdded <- Corpus(VectorSource(wiki$Added))
```

2) Remove the English-language stopwords.
```{r}
corpusAdded <- tm_map(corpusAdded, removeWords, stopwords('english'))
```

3) Stem the words.
```{r}
corpusAdded <- tm_map(corpusAdded, stemDocument)
```

4) Build the DocumentTermMatrix, and call it dtmAdded.
```{r}
dtmAdded <- DocumentTermMatrix(corpusAdded)
```

*How many terms appear in dtmAdded?*
```{r}
dtmAdded
```
**Answer:** `r dtmAdded$ncol`

***

#### Problem 1.3 - Bags of Words

(1 point possible)
Filter out sparse terms by keeping only terms that appear in 0.3% or more of the revisions, and call the new matrix sparseAdded. *How many terms appear in sparseAdded?*
```{r}
sparseAdded <- removeSparseTerms(dtmAdded, .997)
sparseAdded
```
**Answer:** `r sparseAdded$ncol`

***

#### Problem 1.4 - Bags of Words

(2 points possible)
Convert sparseAdded to a data frame called wordsAdded, and then prepend all the words with the letter A.
```{r}
wordsAdded <- as.data.frame(as.matrix(sparseAdded))

colnames(wordsAdded) = paste("A", colnames(wordsAdded))
```
Now repeat all of the steps we've done so far (create a corpus, remove stop words, stem the document, create a sparse document term matrix, and convert it to a data frame) to create a Removed bag-of-words dataframe, called wordsRemoved, except this time, prepend all of the words with the letter R:
```{r}
corpusRemoved <- Corpus(VectorSource(wiki$Removed))
corpusRemoved <- tm_map(corpusRemoved, removeWords, stopwords('english'))
corpusRemoved <- tm_map(corpusRemoved, stemDocument)
dtmRemoved <- DocumentTermMatrix(corpusRemoved)
sparseRemoved <- removeSparseTerms(dtmRemoved, .997)
wordsRemoved <- as.data.frame(as.matrix(sparseRemoved))

colnames(wordsRemoved) = paste("R", colnames(wordsRemoved))
```
*How many words are in the wordsRemoved data frame?*  

**Answer:** `r ncol(wordsRemoved)`

***

#### Problem 1.5 - Bags of Words

(2 points possible)
Combine the two data frames into a data frame called wikiWords.
```{r}
wikiWords <- cbind(wordsAdded, wordsRemoved)
```
Then add the Vandal column. 
```{r}
wikiWords$Vandal <- wiki$Vandal
```
Set the random seed to 123 and then split the data set using sample.split from the "caTools" package to put 70% in the training set.
```{r}
library(caTools)
set.seed(123)

spl <- sample.split(wikiWords$Vandal, SplitRatio = 0.7)
train <- subset(wikiWords, spl == TRUE)
test <- subset(wikiWords, spl == FALSE)
```

*What is the accuracy on the test set of a baseline method that always predicts "not vandalism" (the most frequent outcome)?*
```{r}
baseline_accuracy <- mean(test$Vandal == '0')
```
**Answer:** `r baseline_accuracy`

***

#### Problem 1.6 - Bags of Words

(2 points possible)
Build a CART model to predict Vandal, using all of the other variables as independent variables. Use the training set to build the model and the default parameters (don't set values for minbucket or cp).
```{r}
library(rpart)
library(rpart.plot)

wikiCART <- rpart(Vandal ~ ., data=train, method='class')
```

*What is the accuracy of the model on the test set, using a threshold of 0.5? (Remember that if you add the argument type="class" when making predictions, the output of predict will automatically use a threshold of 0.5.)*
```{r}
predCART <- predict(wikiCART, newdata=test, type='class')
table(test$Vandal, predCART)
```
**Answer:** `r (618 + 12)/nrow(test)`

***

#### Problem 1.7 - Bags of Words

(1 point possible)
Plot the CART tree. *How many word stems does the CART model use?*
```{r}
prp(wikiCART)
```

**Answer:** 2 words.

***

#### Problem 1.8 - Bags of Words

(1 point possible)
*Given the performance of the CART model relative to the baseline, what is the best explanation of these results?*

**Answer:** Although it beats the baseline, bag of words is not very predictive for this problem.

***